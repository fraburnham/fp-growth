<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1417066195885">{:repl-history {:ide [], :local [&quot;(require '[clojure.zip :as zip])&quot; &quot;(defmacro empty-tree []\n  `(zip/seq-zip (seq '())))\n\n(defn next-subbranch [loc]\n  (zip/right (zip/down loc)))\n\n(defn alpha-by-first-char [x]\n  (sort-by (comp str first) compare x))\n\n(defn next-branch [loc]\n  (let [nloc (zip/next loc)]\n    (if (zip/branch? nloc)\n      nloc\n      (recur nloc))))\n\n(defn add-branch [loc]\n  (zip/edit loc\n            (fn [node]\n              (if (empty? (rest node))\n                (conj '(()) (first node))\n                (conj (conj (rest node) '()) (first node))))))\n\n;data is in the format\n;((item item item) (item item item))\n(defn pre-sort [data]\n  (let [freqs (apply (partial merge-with +) (map frequencies data))]\n    (defn item-freq-list [x]\n      (list x (x freqs)))\n    (map #(map first %)\n         (map #(sort-by last &gt;\n                        (alpha-by-first-char (map item-freq-list %)))\n              data))))\n\n(defn find-node-in-branch-this-depth [loc find-key]\n  (if (nil? loc)\n    nil\n    (let [node (zip/node (zip/down loc))\n          k (if (= (type node) (type {}))\n              (first (keys node))\n              nil)]\n      (if (= k find-key)\n        loc\n        (recur (zip/right loc) find-key)))))\n\n;inc the val in the dict that the node holds\n(defn update-node [loc]\n  (zip/edit\n    loc\n    (fn [node]\n      (let [m (first node)\n            k (first (keys m))]\n        (cons {k (inc (k m))} (rest node))))))\n\n;takes an (empty-tree) as loc\n;or an exsisting tree to add to\n(defn build-path [loc path]\n  (if (empty? path)\n    (zip/seq-zip (zip/root loc))\n    (let [new-node {(first path) 1}\n          find-key (first path)\n          nn (if (= (next-subbranch loc) nil) nil\n                                              (find-node-in-branch-this-depth (next-subbranch loc)\n                                                                              find-key))]\n      (if (= nn nil)\n        (do\n          (recur\n            (zip/append-child (next-branch (add-branch loc)) new-node)\n            (rest path)))\n        (recur\n          (update-node nn)\n          (rest path))))))\n\n;this may be the wrong idea\n;maybe this can be done after linking\n;or pass the build path only items\n;that show up in the data only once.\n(defn keep-frequent-nodes [loc cutoff]\n  (if (zip/end? loc)\n    (zip/seq-zip (zip/root loc))\n    (let [node (zip/node loc)]\n      (if (= (type node) (type {}))\n        (let [k (first (keys node))]\n          (if (&lt; (k node) cutoff)\n            (recur (zip/remove (zip/up loc)) cutoff)\n            (recur (zip/next loc) cutoff)))\n        (recur (zip/next loc) cutoff)))))\n\n;GOTTA ZIP NEXT OFF THE ROOT NODE\n(defn keep-branches-with-children [loc]\n  (if (nil? (zip/right loc)) ;this almost works unless the last branch has\n    ;no children\n    (zip/seq-zip (zip/root loc))\n    (if (zip/branch? loc)\n      (let [children (next-subbranch loc)]\n        (if (nil? children)\n          (recur (zip/next (zip/remove loc)))\n          (recur (zip/right loc))))\n      (recur (zip/right loc)))))\n\n;get a list of nodes that appear more than once in the tree\n;the function does not consider the value of the node, only the\n;keyword\n(defn get-list-of-frequent-nodes [loc]\n  (loop [l loc\n         nodes '()]\n    (if (zip/end? l)\n      (take-nth 2 (flatten (filter (fn [[key val]]\n                                     (&gt; val 1)) (frequencies nodes))))\n      (if (zip/branch? l)\n        (recur (zip/next l) nodes)\n        (recur (zip/next l) (conj nodes (first (keys (zip/node l)))))))))\n\n(defn tree-find-key-in-map [loc find]\n  (if (zip/end? loc)\n    nil\n    (if (zip/branch? loc)\n      (recur (zip/next loc) find)\n      (if (= (type (zip/node loc)) (type {}))\n        (let [node (zip/node loc)\n              k (first (keys node))]\n          (if (= k find)\n            loc\n            (recur (zip/next loc) find)))\n        (recur (zip/next loc) find)))))\n\n;returns all nodes in depth first order\n(defn find-all-nodes [loc find]\n  (loop [l loc\n         r '()]\n    (let [nloc (tree-find-key-in-map l find)]\n      (if (nil? nloc)\n        r\n        (recur (zip/next nloc) (concat r (list nloc)))))))\n\n(defn find-all-links [loc freq-nodes]\n  (reduce merge (map #(hash-map % (find-all-nodes loc %)) freq-nodes)))\n\n;now for a full-flow function from getting data to popping out a tree and links\n(defn gen-fp-tree [data support]\n  (let [tree (keep-branches-with-children (keep-frequent-nodes\n                                            (reduce build-path (cons (empty-tree) (pre-sort data))) support))\n        links (find-all-links tree (get-list-of-frequent-nodes tree))]\n    (list tree links)))&quot; &quot;(def my-tree (zip/seq-zip [[1 [2 3 4]] [2] [3] [4 [5 6 7]]]))&quot; &quot;(zip/next (zip/next my-tree))&quot; &quot;(zip/node my-treE)&quot; &quot;(zip/node my-tree)&quot; &quot;(zip/down my-tree)&quot; &quot;(zip/next my-tree)&quot; &quot;(-&gt; my-tree zip/next zip/next zip/next)&quot; &quot;()&quot; &quot;(def my-tree (zip/seq-zip '((1 (2 3 4)) (2) (3) (4 (5 6 7)))))&quot; &quot;my-tree&quot; &quot;(-&gt; my-tree zip/next zip/next zip/next\n    )&quot; &quot;(keep-branches-with-children my-tree)&quot; &quot;(keep-branches-with-children (zip/next my-tree))&quot;], :remote []}}</component>
</project>

