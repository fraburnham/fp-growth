<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ReplState" timestamp="1417625934902">{:repl-history {:ide [], :local [&quot;(def maybe-tree [nil {:changed? true, :l [], :pnodes ['(nil ({:SENSUELLEPOINT2049.99 2}) ({:ENHANCERPILL3.99 2}) ({:HALLOWCONTACTLENSASST34.99 3}) ({:H2OJO8.99 3}) ({:APOLLOMESHBOXERCRING16.99 2}) ({:FINALSALECOSTUMES39.99 2}) ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2} ({:PENISSTRAWASSTCOLORS3.12 2})))))))))], :ppath nil, :r nil}])&quot; &quot;(zip/up maybe-tree)&quot; &quot;(zip/prev maybe-tree)&quot; &quot;maybe-tree&quot; &quot;(defn keep-branches-with-children [loc]\n  (println (zip/end? loc))\n  (cond\n    (zip/end? loc) (zip/seq-zip (zip/root loc))\n    (and\n      (nil? (zip/down loc))\n      (= 1 (count (zip/node (zip/up loc))))) (recur (zip/remove (zip/up loc)))\n    :else (recur (zip/next loc))))&quot; &quot;(defn keep-branches-with-children [loc]\n  (println (zip/end? (zip/next loc)))\n  (cond\n    (zip/end? loc) (zip/seq-zip (zip/root loc))\n    (and\n      (nil? (zip/down loc))\n      (= 1 (count (zip/node (zip/up loc))))) (recur (zip/remove (zip/up loc)))\n    :else (recur (zip/next loc))))&quot; &quot;(defn keep-branches-with-children [loc]\n  (println (zip/end? (zip/next loc)))\n  (cond\n    (zip/end? loc) (zip/seq-zip (zip/root loc))\n    (and\n      (nil? (zip/down loc))\n      (= 1 (count (zip/node (zip/up loc))))) (recur (zip/next (zip/remove (zip/up loc))))\n    :else (recur (zip/next loc))))&quot; &quot;\n(keep-branches-with-children tree)&quot; &quot;(zip/next tree)&quot; &quot;(zip/path (zip/next tree))&quot; &quot;(zip/node (zip/path (zip/next tree)))&quot; &quot;(zip/node (zip/path (zip/down tree)))&quot; &quot;(zip/node (zip/path (-&gt; tree zip/next zip/next zip/next)))&quot; &quot;(zip/path (-&gt; tree zip/next zip/next zip/next))&quot; &quot;(-&gt; tree zip/next zip/next zip/next)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/path)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/up)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/down zip/down)&quot; &quot;(-&gt; tree zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/next zip/down)&quot; &quot;{:header \&quot;SOME BULLSHIT\&quot; :items ({:itemname1 1 2.99} {:itemname2 1 4.99})}&quot; &quot;(def m {:header \&quot;SOME BULLSHIT\&quot; :items ({:itemname1 1 2.99} {:itemname2 1 4.99})})&quot; &quot;(def m {:header \&quot;SOME BULLSHIT\&quot; :items ({:itemname1 2.99} {:itemname2 4.99})})&quot; &quot;(def m {:header \&quot;SOME BULLSHIT\&quot; :items '((\&quot;itemname1\&quot; 1 2.99) (\&quot;itemname2\&quot; 1 4.99))})&quot; &quot;(map first (:items m))&quot; &quot;'(\n  [\n   {:header\n    (\&quot;49542 KRISTINE 07/01/14 11:52:14\&quot;),\n    :items\n    ([\&quot;RHINO 5 19.98\&quot; 1 19.98])}\n   {:header\n    (\&quot;49543 KRISTINE 07/01/14 13:31:17\&quot;),\n    :items\n    ([\&quot;BLUSH 15.99\&quot; 1 15.99])}\n   {:header\n    (\&quot;49544 KRISTINE 07/01/14 14:19:55\&quot;),\n    :items\n    ([\&quot;RAGING HARD ONS 12 19.98\&quot; 1 19.98] [\&quot;VOLT LR44 4.99\&quot; 1 4.99]\n      [\&quot;BODYWAND MIDNITE 59.99\&quot; 1 59.99] [\&quot;PURE ALUMINUM 32.99\&quot; 1 32.99]\n      [\&quot;SIZE BATTERIES 7.99\&quot; 1 7.99] [\&quot;FINAL SALE 29.99\&quot; 1 29.99]\n      [\&quot;SHR 2497 TEDDY 44.99\&quot; 1 44.99] [\&quot;HOSIERY 13.99\&quot; 1 13.99])}])&quot; &quot;(def m '(\n  [\n   {:header\n    (\&quot;49542 KRISTINE 07/01/14 11:52:14\&quot;),\n    :items\n    ([\&quot;RHINO 5 19.98\&quot; 1 19.98])}\n   {:header\n    (\&quot;49543 KRISTINE 07/01/14 13:31:17\&quot;),\n    :items\n    ([\&quot;BLUSH 15.99\&quot; 1 15.99])}\n   {:header\n    (\&quot;49544 KRISTINE 07/01/14 14:19:55\&quot;),\n    :items\n    ([\&quot;RAGING HARD ONS 12 19.98\&quot; 1 19.98] [\&quot;VOLT LR44 4.99\&quot; 1 4.99]\n      [\&quot;BODYWAND MIDNITE 59.99\&quot; 1 59.99] [\&quot;PURE ALUMINUM 32.99\&quot; 1 32.99]\n      [\&quot;SIZE BATTERIES 7.99\&quot; 1 7.99] [\&quot;FINAL SALE 29.99\&quot; 1 29.99]\n      [\&quot;SHR 2497 TEDDY 44.99\&quot; 1 44.99] [\&quot;HOSIERY 13.99\&quot; 1 13.99])}]))&quot; &quot;m&quot; &quot;(map println m)&quot; &quot;(map (fn [day] (map (fn [ticket] (println (:items ticket))) day)) m)&quot; &quot;(map (fn [day] (map (fn [[title quantity price]] price) day)) m)&quot; &quot;(map (fn [day] (map (fn [[title quant price]] price) (map :items day))) m)&quot; &quot;(map (fn [day] (map :items day)) m)&quot; &quot;(map (fn [day] (flatten (map :items day))) m)&quot; &quot;(map (fn [day] (map (fn [item] (println item)) (map :items day))) m)&quot; &quot;(map (fn [day] (map (fn [items] (map (fn [item] (println item)) items)) (map :items day))) m)&quot; &quot;(map (fn [day] (map (fn [items] (map (fn [[t q p]] (println p)) items)) (map :items day))) m)&quot; &quot;(map (fn [day] (map (fn [items] (flatten (map (fn [[t q p]] p) items))) (map :items day))) m)&quot; &quot;(map (fn [day] (flatten (map (fn [items] (map (fn [[t q p]] p) items)) (map :items day)))) m)&quot; &quot;(map (fn [day] (reduce + (flatten (map (fn [items] (map (fn [[t q p]] p) items)) (map :items day))))) m)&quot; &quot;(map (fn [day] [(reduce + (flatten (map (fn [items] (map (fn [[t q p]] p) items)) (map :items day))))]) m)&quot; &quot;(map \n  (fn [day] \n    [(reduce + \n             (flatten \n               (map (fn [items] (map (fn [[t q p]] p) items)) \n                    (map :items day))))]) \n  m)&quot; &quot;(map \n  (fn [day]\n    (println day)\n    [(reduce + \n             (flatten \n               (map (fn [items] (map (fn [[t q p]] p) items)) \n                    (map :items day))))]) \n  m)&quot; &quot;asdf&quot; &quot;(ns fp-growth.core)&quot; &quot;'asdf&quot; &quot;(get-child \n  )&quot; &quot;(def tree (build-tree! #(set! (inc (.-data %))) (new Tree) '(1 2 3)))&quot; &quot;(defn build-tree! [fn-inc-node tree items]\n  (loop [r (.-rootNode tree)\n         items items]\n    (if (empty? items)\n      tree\n      (let [find-child (get-child = r (first items))]\n        ;need to perform a check here to see if the \n        ;child exists and update it otherwise add a new\n        ;child\n        (if (nil? find-child)\n          ;if the child doesn't exist add it\n          (.addChild r (.newNode tree (first items)))\n          ;if the child does exist update the node\n          (fn-inc-node find-child))\n        ;now recur\n        (recur (.getChild r (dec (.getNumNodes r))) (rest items))))))&quot; &quot;(defn build-tree! [fn-inc-node tree items]\n  (loop [r (.-rootNode tree)\n         items items]\n    (if (empty? items)\n      tree\n      (let [find-child (get-child = r (first items))]\n        (if (nil? find-child)\n          (.addChild r (.newNode tree (first items)))\n          (fn-inc-node find-child))\n        (recur (.getChild r (dec (.getNumNodes r))) (rest items))))))&quot; &quot;(defn build-tree! [fn-inc-node tree items]\n  (loop [r (.-rootNode tree)\n         items items]\n    (println (.-data r))\n    (if (empty? items)\n      tree\n      (let [find-child (get-child = r (first items))]\n        (if (nil? find-child)\n          ;if the child doesn't exist add it\n          (.addChild r (.newNode tree (first items)))\n          ;if the child does exist update the node\n          ;(fn-inc-node find-child))\n          (set! (.-data r) \&quot;VISITED DIS HOE\&quot;))\n        ;now recur\n        (recur (.getChild r (dec (.getNumNodes r))) (rest items))))))&quot; &quot;(defn get-child [data-compare root-node child-data]\n  (loop [x (dec (.getNumChildren root-node))]\n    (if (= x -1)\n      nil ;got to the end and saw no matches along the way\n      (let [node (.getChild root-node x)] ;get the xth child of root-node\n        (if (data-compare (.-data node) child-data)\n          node ;found the node\n          (recur (dec x))))))) ;didn't find the node, dec x and check again&quot; &quot;(defn build-tree! [fn-inc-node tree items]\n  (loop [r (.-rootNode tree)\n         items items]\n    (println (.-data r) \&quot; \&quot; (.getNumChildren r))\n    (if (empty? items)\n      tree\n      (let [find-child (get-child = r (first items))]\n        (println find-child)\n        (if (nil? find-child)\n          ;if the child doesn't exist add it\n          (.addChild r (.newNode tree (first items)))\n          ;if the child does exist update the node\n          ;(fn-inc-node find-child))\n          (set! (.-data r) \&quot;VISITED DIS HOE\&quot;))\n\n        ;now recur\n        (recur (.getChild r (dec (.getNumNodes r))) (rest items))))))&quot; &quot;(defn build-tree! [fn-inc-node tree items]\n  (loop [r (.-rootNode tree)\n         items items]\n    (println (.-data r) \&quot; \&quot; (.getNumChildren r))\n    (if (empty? items)\n      tree\n      (let [find-child (get-child = r (first items))]\n        (println find-child)\n        (if (nil? find-child)\n          ;if the child doesn't exist add it\n          (.addChild r (.newNode tree (first items)))\n          ;if the child does exist update the node\n          ;(fn-inc-node find-child))\n          (set! (.-data r) \&quot;VISITED DIS HOE\&quot;))\n\n        ;now recur\n        (recur (.getChild r (dec (.getNumChildren r))) (rest items))))))&quot; &quot;(.getNumChildren (.-rootNode tree))&quot; &quot;(.printTree (tree-interface) (.-rootNode tree))&quot; &quot;(.printTree tree (tree-interface) (.-rootNode tree))&quot; &quot;(defn build-tree! [fn-inc-node tree items]\n  (loop [r (.-rootNode tree)\n         items items]\n    (if (empty? items)\n      tree\n      (let [find-child (get-child = r (first items))]\n        (if (nil? find-child)\n          ;if the child doesn't exist add it\n          (.addChild r (.newNode tree (first items)))\n          ;if the child does exist update the node\n          (fn-inc-node find-child))\n        (recur (.getChild r (dec (.getNumChildren r))) (rest items))))))&quot; &quot;(def tree (build-tree! #(set! (.-data %) (inc (.-data %))) (new Tree) '(1 2 3)))&quot; &quot;(.-data (.rootNode tree))&quot; &quot;(defn fn-inc-node [node]\n  (set! (.-data node) (inc (.-data node))))&quot; &quot;(.-data (.getChild (.rootNode tree) 0))&quot; &quot;(def tree (build-tree! fn-inc-node tree '(1 2 3)))&quot; &quot;(build-tree! fn-inc-node tree '(1 2 3))&quot; &quot;(defn random-ticket [num-items]\n  (repeatedly num-items (rand-int 11)))&quot; &quot;(defn random-ticket [num-items]\n  (repeatedly num-items #(rand-int 11)))&quot; &quot;(random-ticket 5)&quot; &quot;(random-ticket (rand-int 10))&quot; &quot;(take 100 (random-ticket (rand-int 10)))&quot; &quot;(repeatedly 100 #(random-ticket (rand-int 10)))&quot; &quot;(repeatedly 100 #(random-ticket (inc (rand-int 10))))&quot; &quot;(map (partial build-tree! fn-inc-node tree) (repeatedly 100 #(random-ticket (inc (rand-int 10)))))&quot; &quot;(map (partial build-tree! fn-inc-node tree) (repeatedly 100000 #(random-ticket (inc (rand-int 10)))))&quot; &quot;(def tree (new Tree))\n(def data (repeatedly 3000 #(random-ticket (inc (rand-int 10)))))\n(def sorted-mapifyd-data (map mapify-items (pre-sort data 3)))\n(map (partial build-tree! map-visit map-compare tree) sorted-mapifyd-data)\n(prune-children! prune? (.rootNode tree))&quot; &quot;(defn prune-children! [fn-prune? root-node]\n  ;apply fn-prune? to each child-node to determine if it should be pruned\n  (loop [x (dec (.getNumChildren root-node))]\n    (if (= x -1)\n      nil\n      (do\n        (if (fn-prune? (.getChild root-node x))\n          (.removeChild root-node x))\n        (recur (dec x))))))&quot; &quot;(defn prune? [node]\n  (&gt; (.getNumChildren node) 0))&quot; &quot;(import Tree)&quot; &quot;(.printTree tree (.rootNode tree))&quot; &quot;data&quot; &quot;sorted-mapifyd-data&quot; &quot;(defn prune? [node]\n  (println (.-data node))\n  (&gt; (.getNumChildren node) 0))&quot; &quot;(defn prune? [node]\n  (println (.-data node) (&gt; (.getNumChildren node) 0))\n  (&gt; (.getNumChildren node) 0))&quot; &quot;()&quot; &quot;(defn prune? [node]\n  (println (.-data node) (&gt; (.getNumChildren node) 0) (.-data (.getRoot node)))\n  (&gt; (.getNumChildren node) 0))&quot; &quot;(&lt;= 1 2)&quot; &quot;(defn prune? [node]\n  (&lt;= (.getNumChildren node) 0))&quot; &quot;(defn map-visit [node]\n  (let [data (.-data node)\n        k (first (keys data))]\n    (println (k data) (inc (k data)))\n    (set! (.-data node) {k (inc (k data))})))&quot; &quot;(defn map-visit [node]\n  (let [data (.-data node)\n        k (first (keys data))]\n    (println (.-data node))\n    (set! (.-data node) {k (inc (k data))})\n    (println (.-data node))))&quot; &quot;(defn map-visit [node]\n  (let [data (.-data node)\n        k (first (keys data))]\n    (set! (.-data node) {k (inc (k data))})))\n\n  (defn map-compare [node-data data]\n    (let [nk (first (keys node-data))\n          dk (first (keys data))]\n      (println nk dk)\n      (= nk dk)))&quot; &quot;(defn map-compare [node-data data]\n  (let [nk (first (keys node-data))\n        dk (first (keys data))]\n    (if (= nk dk)\n      (println nk dk))\n    (= nk dk)))&quot; &quot;(defn map-visit [node]\n  (let [data (.-data node)\n        k (first (keys data))]\n    (set! (.-data node) {k (inc (k data))})))\n\n(defn map-compare [node-data data]\n  (let [nk (first (keys node-data))\n        dk (first (keys data))]\n    (= nk dk)))&quot; &quot;(def tree (new Tree))&quot; &quot;(prune-children! prune? (.rootNode tree))&quot; &quot;(ns user)&quot; &quot;(defn map-visit [node]\n  (let [data (.-data node)\n        k (first (keys data))]\n    (.setData (.-data node) {k (inc (k data))})))&quot; &quot;tree&quot; &quot;(.printTree tree (tree-interface) (.rootNode tree))&quot; &quot;(map (partial build-tree! map-visit map-compare tree) sorted-mapifyd-data)&quot;], :remote []}}</component>
</project>

